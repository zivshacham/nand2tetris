import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/*
 * Created by Ziv Shacham on January 2023
 */

/**
 * CompilationEngine: Compiles the jack tokens from the JackTokenizer into
 * corresponding XML code.
 * • Gets its input from a JackTokenizer, and emits its output to an output file
 * • The output is generated by a series of compileXXX routines,
 * structured according to the grammar rules that define XXX
 * • Each compileXXX routine is responsible for handling all the tokens that
 * make up XXX,
 * advancing the tokenizer exactly beyond these tokens, and outputing the
 * parsing of XXX.
 */
public class CompilationEngine {
    private FileWriter fileWriter;
    private JackTokenizer jackTokenizer;
    private boolean isFirstTime;

    /**
     * Constructor / initializer():
     * Creates a new CompilationEngine with the given input and output.
     * if can't open the file - a message is displayed.
     * The next routine called (by the JackAnalyzer module) must be compileClass.
     * 
     * @param inputFile:  the input file
     * @param outputFile: the output file
     */
    public CompilationEngine(File inputFile, File outputFile) {
        try {
            fileWriter = new FileWriter(outputFile);
            jackTokenizer = new JackTokenizer(inputFile);
        } catch (IOException e) {
            System.out.println("An error occurred.");
        }
        isFirstTime = true;
    }

    /**
     * compileClass():
     * Compiles a complete class.
     * 
     * @throws IOException
     */
    public void compileClass() {
        try {
            jackTokenizer.advance();
            fileWriter.write("<class>\n");
            fileWriter.write("<keyword> class </keyword>\n");
            jackTokenizer.advance();
            fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
            jackTokenizer.advance();
            fileWriter.write("<symbol> { </symbol>\n");
            compileClassVarDec();
            compileSubroutine();
            fileWriter.write("<symbol> } </symbol>\n");
            fileWriter.write("</class>\n");
            fileWriter.close();
        } catch (IOException e) {
            System.out.println("An error occurred (compileClass).");
        }
    }

    /**
     * compileClassVarDec():
     * Compiling a static variable declaration or a field declaration.
     * 
     * @throws IOException
     */
    public void compileClassVarDec() {
        jackTokenizer.advance();
        try {
            while (jackTokenizer.getKeyWord().equals("static") || jackTokenizer.getKeyWord().equals("field")) {
                fileWriter.write("<classVarDec>\n");
                fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                jackTokenizer.advance();
                if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                    fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                } else {
                    fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                }
                jackTokenizer.advance();
                fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                jackTokenizer.advance();
                if (jackTokenizer.getSymbol() == ',') {
                    fileWriter.write("<symbol> , </symbol>\n");
                    jackTokenizer.advance();
                    fileWriter.write(("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n"));
                    jackTokenizer.advance();
                }
                // end of line with semicolon
                fileWriter.write("<symbol> ; </symbol>\n");
                jackTokenizer.advance();
                fileWriter.write("</classVarDec>\n");
            }
            if (jackTokenizer.getKeyWord().equals("function") || jackTokenizer.getKeyWord().equals("method")
                    || jackTokenizer.getKeyWord().equals("constructor")) {
                jackTokenizer.decrementCounter();
                return;
            }
        } catch (IOException e) {
            System.out.println("An error occurred (compileClassVarDec).");
        }
    }

    /**
     * compileSubroutine():
     * Compiles a complete method, function or constructor.
     * This function is also used to compiles the subroutine's body.
     * 
     * @throws IOException
     */
    public void compileSubroutine() {
        boolean hasSubRoutines = false;
        jackTokenizer.advance();
        try {
            if (jackTokenizer.getSymbol() == '}' && jackTokenizer.getTokenType().equals("SYMBOL")) {
                return;
            }
            if ((isFirstTime)
                    && (jackTokenizer.getKeyWord().equals("function") || jackTokenizer.getKeyWord().equals("method")
                            || jackTokenizer.getKeyWord().equals("constructor"))) {
                isFirstTime = false;
                fileWriter.write("<subroutineDec>\n");
                hasSubRoutines = true;
            }
            if (jackTokenizer.getKeyWord().equals("function") || jackTokenizer.getKeyWord().equals("method")
                    || jackTokenizer.getKeyWord().equals("constructor")) {
                hasSubRoutines = true;
                fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                jackTokenizer.advance();
            }
            if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                jackTokenizer.advance();
            } else if (jackTokenizer.getTokenType().equals("KEYWORD")) {
                fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                jackTokenizer.advance();
            }
            if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                jackTokenizer.advance();
            }
            if (jackTokenizer.getSymbol() == '(') {
                fileWriter.write("<symbol> ( </symbol>\n");
                fileWriter.write("<parameterList>\n");
                compileParameterList();
                fileWriter.write("</parameterList>\n");
                fileWriter.write("<symbol> ) </symbol>\n");
            }
            jackTokenizer.advance();
            if (jackTokenizer.getSymbol() == '{') {
                fileWriter.write("<subroutineBody>\n");
                fileWriter.write("<symbol> { </symbol>\n");
                jackTokenizer.advance();
            }
            while (jackTokenizer.getKeyWord().equals("var") && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<varDec>\n ");
                jackTokenizer.decrementCounter();
                compileVarDec();
                fileWriter.write(" </varDec>\n");
            }
            fileWriter.write("<statements>\n");
            compileStatements();
            fileWriter.write(" </statements>\n");
            fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
            if (hasSubRoutines) {
                fileWriter.write(" </subroutineBody>\n");
                fileWriter.write(" </subroutineDec>\n");
                isFirstTime = true;
            }
            // this is the recursive call of the function
            compileSubroutine();
        } catch (IOException e) {
            System.out.println("An error occurred (compileSubRoutine).");
        }
    }

    /**
     * compileParameterList():
     * Compiles a (possibly empty) parameter list.
     * 
     * @throws IOException
     */
    public void compileParameterList() {
        jackTokenizer.advance();
        try {
            while (!(jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.getSymbol() == ')')) {
                if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                    fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                    jackTokenizer.advance();
                } else if (jackTokenizer.getTokenType().equals("KEYWORD")) {
                    fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                    jackTokenizer.advance();
                } else if ((jackTokenizer.getTokenType().equals("SYMBOL")) && (jackTokenizer.getSymbol() == ',')) {
                    fileWriter.write("<symbol> , </symbol>\n");
                    jackTokenizer.advance();
                }
            }
        } catch (IOException e) {
            System.out.println("An error occurred (compileParameterList).");
        }
    }

    /**
     * compileVarDec():
     * Compiles a var declaration.
     * 
     * @throws IOException
     */
    public void compileVarDec() {
        jackTokenizer.advance();
        try {
            if (jackTokenizer.getKeyWord().equals("var") && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<keyword> var </keyword>\n");
                jackTokenizer.advance();
            }
            if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                jackTokenizer.advance();
            } else if (jackTokenizer.getTokenType().equals("KEYWORD")) {
                fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                jackTokenizer.advance();
            }
            if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                jackTokenizer.advance();
            }
            if ((jackTokenizer.getTokenType().equals("SYMBOL")) && (jackTokenizer.getSymbol() == ',')) {
                fileWriter.write("<symbol> , </symbol>\n");
                jackTokenizer.advance();
                fileWriter.write(("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n"));
                jackTokenizer.advance();
            }
            if ((jackTokenizer.getTokenType().equals("SYMBOL")) && (jackTokenizer.getSymbol() == ';')) {
                fileWriter.write("<symbol> ; </symbol>\n");
                jackTokenizer.advance();
            }
        } catch (IOException e) {
            System.out.println("An error occurred (compileVarDec).");
        }
    }

    /**
     * compileStatements():
     * Compiles a sequence of statements.
     * 
     * @throws IOException
     */
    public void compileStatements() {
        try {
            if (jackTokenizer.getSymbol() == '}' && (jackTokenizer.getTokenType().equals("SYMBOL"))) {
                return;
            } else if (jackTokenizer.getKeyWord().equals("do") && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<doStatement>\n ");
                compileDo();
                fileWriter.write((" </doStatement>\n"));
            } else if (jackTokenizer.getKeyWord().equals("let") && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<letStatement>\n ");
                compileLet();
                fileWriter.write((" </letStatement>\n"));
            } else if (jackTokenizer.getKeyWord().equals("if") && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<ifStatement>\n ");
                compileIf();
                fileWriter.write((" </ifStatement>\n"));
            } else if (jackTokenizer.getKeyWord().equals("while") && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<whileStatement>\n ");
                compileWhile();
                fileWriter.write((" </whileStatement>\n"));
            } else if (jackTokenizer.getKeyWord().equals("return")
                    && (jackTokenizer.getTokenType().equals("KEYWORD"))) {
                fileWriter.write("<returnStatement>\n ");
                compileReturn();
                fileWriter.write((" </returnStatement>\n"));
            }
            jackTokenizer.advance();
            // this is the recursive call of the function
            compileStatements();
        } catch (IOException e) {
            System.out.println("An error occurred (compileStatements).");
        }
    }

    /**
     * compileLet():
     * Compiles a let statement.
     * 
     * @throws IOException
     */
    public void compileLet() {
        try {
            fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
            jackTokenizer.advance();
            fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
            jackTokenizer.advance();
            if ((jackTokenizer.getTokenType().equals("SYMBOL")) && (jackTokenizer.getSymbol() == '[')) {
                fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
                compileExpression();
                jackTokenizer.advance();
                if ((jackTokenizer.getTokenType().equals("SYMBOL")) && ((jackTokenizer.getSymbol() == ']'))) {
                    fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
                }
                jackTokenizer.advance();
            }
            fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
            compileExpression();
            fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
            jackTokenizer.advance();
        } catch (IOException e) {
            System.out.println("An error occurred (compileLet).");
        }
    }

    /**
     * compileIf():
     * Compiles an if statement,
     * possibly with a trailing else clause.
     * 
     * @throws IOException
     */
    public void compileIf() {
        try {
            fileWriter.write("<keyword> if </keyword>\n");
            jackTokenizer.advance();
            fileWriter.write("<symbol> ( </symbol>\n");
            compileExpression();
            fileWriter.write("<symbol> ) </symbol>\n");
            jackTokenizer.advance();
            fileWriter.write("<symbol> { </symbol>\n");
            jackTokenizer.advance();
            fileWriter.write("<statements>\n");
            compileStatements();
            fileWriter.write("</statements>\n");
            fileWriter.write("<symbol> } </symbol>\n");
            jackTokenizer.advance();
            if (jackTokenizer.getTokenType().equals("KEYWORD") && jackTokenizer.getKeyWord().equals("else")) {
                fileWriter.write("<keyword> else </keyword>\n");
                jackTokenizer.advance();
                fileWriter.write("<symbol> { </symbol>\n");
                jackTokenizer.advance();
                fileWriter.write("<statements>\n");
                compileStatements();
                fileWriter.write("</statements>\n");
                fileWriter.write("<symbol> } </symbol>\n");
            } else {
                jackTokenizer.decrementCounter();
            }
        } catch (IOException e) {
            System.out.println("An error occurred (compileIf).");
        }
    }

    /**
     * compileWhile():
     * Compiles a while statement.
     * 
     * @throws IOException
     */
    public void compileWhile() {
        try {
            fileWriter.write("<keyword>" + jackTokenizer.getKeyWord() + "</keyword>\n");
            jackTokenizer.advance();
            fileWriter.write("<symbol>" + jackTokenizer.getSymbol() + "</symbol>\n");
            compileExpression();
            jackTokenizer.advance();
            fileWriter.write("<symbol>" + jackTokenizer.getSymbol() + "</symbol>\n");
            jackTokenizer.advance();
            fileWriter.write("<symbol>" + jackTokenizer.getSymbol() + "</symbol>\n");
            fileWriter.write("<statements>\n");
            compileStatements();
            fileWriter.write("</statements>\n");
            fileWriter.write("<symbol>" + jackTokenizer.getSymbol() + "</symbol>\n");
        } catch (IOException e) {
            System.out.println("An error occurred (compileWhile).");
        }
    }

    /**
     * compileDo():
     * Compiles a do statement.
     * 
     * @throws IOException
     */
    public void compileDo() {
        try {
            if (jackTokenizer.getKeyWord().equals("do")) {
                fileWriter.write("<keyword> do </keyword>\n");
            }
            compileCall();
            jackTokenizer.advance();
            fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
        } catch (IOException e) {
            System.out.println("An error occurred (compileDo).");
        }
    }

    /**
     * compileReturn():
     * Compiles a return statement.
     * 
     * @throws IOException
     */
    public void compileReturn() {
        try {
            fileWriter.write("<keyword> return </keyword>\n");
            jackTokenizer.advance();
            if (!((jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.getSymbol() == ';'))) {
                jackTokenizer.decrementCounter();
                compileExpression();
            }
            if (jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.getSymbol() == ';') {
                fileWriter.write("<symbol> ; </symbol>\n");
            }
        } catch (IOException e) {
            System.out.println("An error occurred (compileReturn).");
        }
    }

    /**
     * compileCall():
     * Compiles a call statement.
     * 
     * @throws IOException
     */
    private void compileCall() {
        jackTokenizer.advance();
        try {
            fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
            jackTokenizer.advance();
            if ((jackTokenizer.getTokenType().equals("SYMBOL")) && (jackTokenizer.getSymbol() == '.')) {
                fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
                jackTokenizer.advance();
                fileWriter.write("<identifier> " + jackTokenizer.getIdentifier() + " </identifier>\n");
                jackTokenizer.advance();
                fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
                fileWriter.write("<expressionList>\n");
                compileExpressionList();
                fileWriter.write(" </expressionList>\n");
                jackTokenizer.advance();
                fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
            } else if ((jackTokenizer.getTokenType().equals("SYMBOL")) && (jackTokenizer.getSymbol() == '(')) {
                fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
                fileWriter.write("<expressionList>\n");
                compileExpressionList();
                fileWriter.write(" </expressionList>\n");
                jackTokenizer.advance();
                fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
            }
        } catch (IOException e) {
            System.out.println("An error occurred (compileCall).");
        }
    }

    /**
     * compileExpression():
     * Compiles an expression.
     * 
     * @throws IOException
     */
    public void compileExpression() {
        try {
            fileWriter.write("<expression>\n");
            compileTerm();
            while (true) {
                jackTokenizer.advance();
                if (jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.isOperation()) {
                    if (jackTokenizer.getSymbol() == '<') {
                        fileWriter.write("<symbol> &lt; </symbol>\n");
                    } else if (jackTokenizer.getSymbol() == '>') {
                        fileWriter.write("<symbol> &gt; </symbol>\n");
                    } else if (jackTokenizer.getSymbol() == '&') {
                        fileWriter.write("<symbol> &amp; </symbol>\n");
                    } else {
                        fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + " </symbol>\n");
                    }
                    compileTerm();
                } else {
                    jackTokenizer.decrementCounter();
                    break;
                }
            }
            fileWriter.write("</expression>\n");
        } catch (IOException e) {
            System.out.println("An error occurred (compileExpression).");
        }
    }

    /**
     * compileTerm(): This function is regarding to Project 11.
     * Compiles an term.
     * If current token is an identifier, the routine must resolve it
     * into a variable, array entry, and subroutine call.
     * A single lookahead token which may be '[' '(' or '.', suffices
     * to distinguish between the possibilities.
     * Any other token is not part of this term and should not be advanced over.
     * 
     * @throws IOException
     */
    public void compileTerm() {
        try {
            fileWriter.write("<term>\n");
            jackTokenizer.advance();
            if (jackTokenizer.getTokenType().equals("IDENTIFIER")) {
                String prevIdentifier = jackTokenizer.getIdentifier();
                jackTokenizer.advance();
                if (jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.getSymbol() == '[') {
                    fileWriter.write("<identifier> " + prevIdentifier + " </identifier>\n");
                    fileWriter.write("<symbol> [ </symbol>\n");
                    compileExpression();
                    jackTokenizer.advance();
                    fileWriter.write("<symbol> ] </symbol>\n");
                }
                else if (jackTokenizer.getTokenType().equals("SYMBOL")
                        && (jackTokenizer.getSymbol() == '(' || jackTokenizer.getSymbol() == '.')) {
                    jackTokenizer.decrementCounter();
                    jackTokenizer.decrementCounter();
                    compileCall();
                } else {
                    fileWriter.write("<identifier> " + prevIdentifier + " </identifier>\n");
                    jackTokenizer.decrementCounter();
                }
            } else {
                if (jackTokenizer.getTokenType().equals("INT_CONST")) {
                    fileWriter.write("<integerConstant> " + jackTokenizer.getIntVal() + " </integerConstant>\n");
                }
                else if (jackTokenizer.getTokenType().equals("STRING_CONST")) {
                    fileWriter.write("<stringConstant> " + jackTokenizer.getStringVal() + " </stringConstant>\n");
                }
                else if (jackTokenizer.getTokenType().equals("KEYWORD")
                        && (jackTokenizer.getKeyWord().equals("this") || jackTokenizer.getKeyWord().equals("null")
                                || jackTokenizer.getKeyWord().equals("false")
                                || jackTokenizer.getKeyWord().equals("true"))) {
                    fileWriter.write("<keyword> " + jackTokenizer.getKeyWord() + " </keyword>\n");
                }
                else if (jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.getSymbol() == '(') {
                    fileWriter.write("<symbol>" + jackTokenizer.getSymbol() + "</symbol>\n");
                    compileExpression();
                    jackTokenizer.advance();
                    fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + "</symbol>\n");
                }
                else if (jackTokenizer.getTokenType().equals("SYMBOL")
                        && (jackTokenizer.getSymbol() == '-' || jackTokenizer.getSymbol() == '~')) {
                    fileWriter.write("<symbol> " + jackTokenizer.getSymbol() + "</symbol>\n");
                    // this is the recursive call of the function
                    compileTerm();
                }
            }
            fileWriter.write("</term>\n");
        } catch (IOException e) {
            System.out.println("An error occurred (compileTerm).");
        }
    }

    /**
     * compileExpressionList(): This function is regarding to Project 11.
     * Compiles a (possibly empty) comma separated list of expressions.
     * Returns the number of expressions in the list.
     * 
     * @throws IOException
     */
    public void compileExpressionList() {
        jackTokenizer.advance();
        if (jackTokenizer.getSymbol() == ')' && jackTokenizer.getTokenType().equals("SYMBOL")) {
            jackTokenizer.decrementCounter();
        } else {
            jackTokenizer.decrementCounter();
            compileExpression();
        }
        while (true) {
            jackTokenizer.advance();
            if (jackTokenizer.getTokenType().equals("SYMBOL") && jackTokenizer.getSymbol() == ',') {
                try {
                    fileWriter.write("<symbol> , </symbol>\n");
                } catch (IOException e) {
                    System.out.println("An error occurred (compileExpressionList).");
                }
                compileExpression();
            } else {
                jackTokenizer.decrementCounter();
                break;
            }
        }
    }
}